// Copyright 2026 Element Creations Ltd.
//
// SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-Element-Commercial
// Please see LICENSE files in the repository root for full details.

use std::{collections::BTreeMap, fmt::Write as _};

use camino::{Utf8Path, Utf8PathBuf};
use reqwest::Client;
use serde::Deserialize;
use tokio::io::AsyncWriteExt;
use tracing::Level;
use uuid::Uuid;

const AAGUID_URL: &str = "https://raw.githubusercontent.com/passkeydeveloper/passkey-authenticator-aaguids/main/combined_aaguid.json";

#[derive(Debug, Deserialize)]
struct AaguidEntry {
    name: String,
    #[allow(dead_code)]
    #[serde(default)]
    icon_light: Option<String>,
    #[allow(dead_code)]
    #[serde(default)]
    icon_dark: Option<String>,
}

fn resolve_path(relative: impl AsRef<Utf8Path>) -> Utf8PathBuf {
    let crate_root = Utf8Path::new(env!("CARGO_MANIFEST_DIR"));
    let workspace_root = crate_root.parent().unwrap().parent().unwrap();
    workspace_root.join(relative)
}

#[tracing::instrument(skip_all)]
async fn fetch_aaguids(client: &Client) -> anyhow::Result<BTreeMap<Uuid, String>> {
    tracing::info!("Fetching AAGUID data from {AAGUID_URL}");

    #[expect(
        clippy::disallowed_methods,
        reason = "send_traced is not available in codegen"
    )]
    let response = client.get(AAGUID_URL).send().await?;
    let data: BTreeMap<String, AaguidEntry> = response.json().await?;

    let mut result = BTreeMap::new();
    for (uuid_str, entry) in data {
        match Uuid::parse_str(&uuid_str) {
            Ok(uuid) => {
                result.insert(uuid, entry.name);
            }
            Err(e) => {
                tracing::warn!("Failed to parse UUID {uuid_str}: {e}");
            }
        }
    }

    tracing::info!("Loaded {} AAGUID entries", result.len());
    Ok(result)
}

fn generate_code(aaguids: &BTreeMap<Uuid, String>) -> String {
    let mut code = String::new();

    code.push_str(
        "// Copyright 2026 Element Creations Ltd.
//
// SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-Element-Commercial
// Please see LICENSE files in the repository root for full details.

// Do not edit this file manually.
// Generated by mas-aaguid-codegen

use std::{collections::BTreeMap, sync::LazyLock};

use uuid::{Uuid, uuid};

#[rustfmt::skip]
pub(crate) static AAGUIDS: LazyLock<BTreeMap<Uuid, &'static str>> = LazyLock::new(|| {
    BTreeMap::from([
",
    );

    for (uuid, name) in aaguids {
        // Escape any special characters in the name
        let escaped_name = name.replace('\\', "\\\\").replace('"', "\\\"");
        writeln!(code, "        (uuid!(\"{uuid}\"), \"{escaped_name}\"),").unwrap();
    }

    code.push_str(
        "    ])
});
",
    );

    code
}

#[tracing::instrument(skip_all, fields(%path))]
async fn write_file(
    path: impl AsRef<Utf8Path> + std::fmt::Display,
    content: &str,
) -> anyhow::Result<()> {
    let path = resolve_path(path);
    tracing::info!("Writing file to {path}");

    let mut file = tokio::fs::OpenOptions::new()
        .create(true)
        .truncate(true)
        .write(true)
        .open(path.as_std_path())
        .await?;

    file.write_all(content.as_bytes()).await?;
    Ok(())
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt()
        .with_max_level(Level::INFO)
        .pretty()
        .init();

    let provider = std::sync::Arc::new(rustls::crypto::aws_lc_rs::default_provider());
    let verifier = rustls_platform_verifier::Verifier::new(provider.clone()).unwrap();
    let client = Client::builder()
        .use_preconfigured_tls(
            rustls::ClientConfig::builder_with_provider(provider)
                .with_safe_default_protocol_versions()?
                .dangerous()
                .with_custom_certificate_verifier(std::sync::Arc::new(verifier))
                .with_no_client_auth(),
        )
        .build()?;

    let aaguids = fetch_aaguids(&client).await?;
    let code = generate_code(&aaguids);

    write_file("crates/aaguid/src/data.rs", &code).await?;

    tracing::info!("Done!");
    Ok(())
}
